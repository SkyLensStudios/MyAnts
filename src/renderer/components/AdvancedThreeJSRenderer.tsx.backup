import React, { useEffect, useRef, useState } from 'reac  });

  // Memory management functions
  const initializeObjectPools = () => {
    // Create reusable geometries
    geometryPoolRef.current.antBody = new THREE.CapsuleGeometry(1.0, 2.5, 6, 8);
    geometryPoolRef.current.antHead = new THREE.SphereGeometry(0.8, 12, 8);
    geometryPoolRef.current.antLeg = new THREE.CylinderGeometry(0.15, 0.15, 1.5);

    // Create reusable materials
    materialPoolRef.current.antBody = new THREE.MeshLambertMaterial({ color: 0x000000 });
    materialPoolRef.current.antHead = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
    materialPoolRef.current.antLeg = new THREE.MeshLambertMaterial({ color: 0x000000 });

    console.log('Object pools initialized for memory efficiency');
  };

  const disposeObjectPools = () => {
    // Dispose of geometries
    geometryPoolRef.current.antBody?.dispose();
    geometryPoolRef.current.antHead?.dispose();
    geometryPoolRef.current.antLeg?.dispose();

    // Dispose of materials
    materialPoolRef.current.antBody?.dispose();
    materialPoolRef.current.antHead?.dispose();
    materialPoolRef.current.antLeg?.dispose();

    // Clear references
    geometryPoolRef.current = {};
    materialPoolRef.current = {};

    console.log('Object pools disposed');
  };

  const disposeAntMesh = (antGroup: THREE.Group) => {
    // Traverse and dispose of geometries and materials for individual meshes
    antGroup.traverse((child) => {
      if (child instanceof THREE.Mesh) {
        // Only dispose if it's not from the shared pool (custom geometries/materials)
        if (child.geometry !== geometryPoolRef.current.antBody &&
            child.geometry !== geometryPoolRef.current.antHead &&
            child.geometry !== geometryPoolRef.current.antLeg) {
          child.geometry.dispose();
        }
        
        if (child.material !== materialPoolRef.current.antBody &&
            child.material !== materialPoolRef.current.antHead &&
            child.material !== materialPoolRef.current.antLeg) {
          if (Array.isArray(child.material)) {
            child.material.forEach(material => material.dispose());
          } else {
            child.material.dispose();
          }
        }
      }
    });
  };

  const disposeAllAntMeshes = () => {
    // Dispose of all existing ant meshes
    Object.values(antMeshesRef.current).forEach(antGroup => {
      disposeAntMesh(antGroup);
    });
    antMeshesRef.current = {};
    console.log('All ant meshes disposed');
  };

  const disposePheromoneSystem = () => {
    if (pheromoneSystemRef.current) {
      pheromoneSystemRef.current.geometry.dispose();
      if (Array.isArray(pheromoneSystemRef.current.material)) {
        pheromoneSystemRef.current.material.forEach(material => material.dispose());
      } else {
        pheromoneSystemRef.current.material.dispose();
      }
      sceneRef.current?.remove(pheromoneSystemRef.current);
      pheromoneSystemRef.current = null;
    }
  };

  // Initialize Three.js scene
import * as THREE from 'three';
import { AntRenderData, PheromoneRenderData, FoodSource, EnvironmentRenderData, SimulationState } from '../../shared/types';
import DevToolsPanel from './DevToolsPanel';
import { VisualDebugRenderer } from './VisualDebugRenderer';

interface AdvancedThreeJSRendererProps {
  antData: AntRenderData[];
  pheromoneData: PheromoneRenderData[];
  environmentData: EnvironmentRenderData;
  simulationState: SimulationState;
  onAntSelected?: (antId: string) => void;
  selectedAnt?: string | null;
}

const AdvancedThreeJSRenderer: React.FC<AdvancedThreeJSRendererProps> = ({
  antData,
  pheromoneData,
  environmentData,
  simulationState,
  onAntSelected,
  selectedAnt
}) => {
  const mountRef = useRef<HTMLDivElement>(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const antMeshesRef = useRef<{ [antId: string]: THREE.Group }>({});
  const antGroupRef = useRef<THREE.Group | null>(null);
  const pheromoneSystemRef = useRef<THREE.Points | null>(null);
  const animationIdRef = useRef<number | null>(null);
  const visualDebugRendererRef = useRef<VisualDebugRenderer | null>(null);
  
  // Memory management for object pooling
  const geometryPoolRef = useRef<{
    antBody?: THREE.CapsuleGeometry;
    antHead?: THREE.SphereGeometry;
    antLeg?: THREE.CylinderGeometry;
  }>({});
  const materialPoolRef = useRef<{
    antBody?: THREE.MeshLambertMaterial;
    antHead?: THREE.MeshLambertMaterial;
    antLeg?: THREE.MeshLambertMaterial;
  }>({});
  const [isInitialized, setIsInitialized] = useState(false);
  const [debugInfo, setDebugInfo] = useState<string>('');
  const [renderCount, setRenderCount] = useState(0);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const [showDevTools, setShowDevTools] = useState(true);
  const [overlayStates, setOverlayStates] = useState({
    pheromoneTrails: false,
    antPaths: false,
    visionCones: false,
    foodDetection: false,
    taskColors: true,
    antIDs: false
  });

    // Initialize Three.js scene
  useEffect(() => {
    if (!mountRef.current || isInitialized) return;

    console.log('Initializing Three.js scene...');
    setErrorMessage(null);

    try {
      // Scene setup
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x222244);
      scene.fog = new THREE.Fog(0x222244, 50, 500);
      sceneRef.current = scene;

      // Camera setup
      const camera = new THREE.PerspectiveCamera(
        45,
        mountRef.current.clientWidth / mountRef.current.clientHeight,
        0.1,
        1000
      );
      camera.position.set(20, 30, 40);
      camera.lookAt(0, 0, 0);
      cameraRef.current = camera;

      // Renderer setup with optimized settings
      const renderer = new THREE.WebGLRenderer({ 
        antialias: false, // Disable for better performance
        powerPreference: 'high-performance',
        precision: 'mediump' // Use medium precision for better performance
      });
      renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFShadowMap;
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio
      rendererRef.current = renderer;

      mountRef.current.appendChild(renderer.domElement);

      // Initialize object pools for memory efficiency
      initializeObjectPools();

      // Lighting setup
      setupLighting(scene);

      // Environment setup
      setupEnvironment(scene);

      // Add test object to confirm rendering works
      addTestObject(scene);

      // Create ant group for better management
      const antGroup = new THREE.Group();
      scene.add(antGroup);
      antGroupRef.current = antGroup;

      // Initialize visual debug renderer
      visualDebugRendererRef.current = new VisualDebugRenderer(scene);

      // Controls setup
      setupControls(camera, renderer);

      // Start render loop
      startRenderLoop();

      setIsInitialized(true);
      console.log('Three.js scene initialized successfully');

      // Test if WebGL is working properly
      const gl = renderer.getContext();
      const debugExtension = gl.getExtension('WEBGL_debug_renderer_info');
      if (debugExtension) {
        const vendor = gl.getParameter(debugExtension.UNMASKED_VENDOR_WEBGL);
        const renderer = gl.getParameter(debugExtension.UNMASKED_RENDERER_WEBGL);
        console.log(`WebGL: ${vendor} - ${renderer}`);
        setDebugInfo(prev => prev + `\nWebGL: ${vendor} - ${renderer}`);
      }

      // Cleanup function with proper memory disposal
      return () => {
        if (animationIdRef.current) {
          cancelAnimationFrame(animationIdRef.current);
        }
        
        // Dispose of visual debug renderer
        if (visualDebugRendererRef.current) {
          visualDebugRendererRef.current.dispose();
        }
        
        // Dispose of all ant meshes and their resources
        disposeAllAntMeshes();
        
        // Dispose of object pools
        disposeObjectPools();
        
        // Dispose of pheromone system
        if (pheromoneSystemRef.current) {
          disposePheromoneSystem();
        }
        
        // Remove renderer from DOM and dispose
        if (mountRef.current && renderer.domElement) {
          mountRef.current.removeChild(renderer.domElement);
        }
        renderer.dispose();
        
        console.log('Three.js scene and resources disposed');
      };
    } catch (error) {
      console.error('Error initializing Three.js scene:', error);
      setErrorMessage(`Three.js initialization error: ${error instanceof Error ? error.message : String(error)}`);
    }
  }, []);

  // Add a simple test object to verify rendering works
  const addTestObject = (scene: THREE.Scene) => {
    try {
      const geometry = new THREE.BoxGeometry(2, 2, 2); // Much smaller test cube
      const material = new THREE.MeshLambertMaterial({ color: 0xff0000 });
      const cube = new THREE.Mesh(geometry, material);
      cube.position.set(10, 1, 10); // Move to corner to not interfere with ants
      cube.castShadow = true;
      scene.add(cube);
      console.log('Added test cube to scene');
    } catch (error) {
      console.error('Error adding test object:', error);
    }
  };

  // Setup lighting system
  const setupLighting = (scene: THREE.Scene) => {
    try {
      // Brighter ambient light for better visibility
      const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
      scene.add(ambientLight);

      // Main directional light (sun)
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(50, 100, 50);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 0.5;
      directionalLight.shadow.camera.far = 200;
      directionalLight.shadow.camera.left = -100;
      directionalLight.shadow.camera.right = 100;
      directionalLight.shadow.camera.top = 100;
      directionalLight.shadow.camera.bottom = -100;
      scene.add(directionalLight);

      // Additional point lights for better ant visibility
      const pointLight1 = new THREE.PointLight(0xffffff, 0.7, 100);
      pointLight1.position.set(-30, 20, -30);
      scene.add(pointLight1);

      const pointLight2 = new THREE.PointLight(0xffffff, 0.7, 100);
      pointLight2.position.set(30, 20, 30);
      scene.add(pointLight2);
    } catch (error) {
      console.error('Error setting up lighting:', error);
    }
  };

  // Setup environment (ground, nest, food sources)
  const setupEnvironment = (scene: THREE.Scene) => {
    try {
      // SMALLER ground plane for better scale
      const groundGeometry = new THREE.PlaneGeometry(100, 100);
      const groundMaterial = new THREE.MeshLambertMaterial({ 
        color: 0x8B7355,
        transparent: false, // Change to false for better visibility
        opacity: 1.0
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      ground.position.y = -0.1; // Slightly below to prevent z-fighting
      scene.add(ground);

      // SMALLER nest structure
      const nestGeometry = new THREE.CylinderGeometry(4, 5, 1, 16); // More segments for smoother look
      const nestMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
      const nest = new THREE.Mesh(nestGeometry, nestMaterial);
      nest.position.set(0, 0.5, 0);
      nest.castShadow = true;
      nest.receiveShadow = true;
      scene.add(nest);

      // Add some environmental details (smaller scale)
      for (let i = 0; i < 5; i++) {
        const rockGeometry = new THREE.DodecahedronGeometry(Math.random() * 1 + 0.5);
        const rockMaterial = new THREE.MeshLambertMaterial({ color: 0x696969 });
        const rock = new THREE.Mesh(rockGeometry, rockMaterial);
        rock.position.set(
          (Math.random() - 0.5) * 80,
          Math.random() * 1 + 0.5, // Always above ground
          (Math.random() - 0.5) * 80
        );
        rock.castShadow = true;
        rock.receiveShadow = true;
        scene.add(rock);
      }
    } catch (error) {
      console.error('Error setting up environment:', error);
    }
  };

  // Setup camera controls
  const setupControls = (camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer) => {
    try {
      let isDragging = false;
      let previousMousePosition = { x: 0, y: 0 };

      const onMouseDown = (event: MouseEvent) => {
        isDragging = true;
        previousMousePosition = { x: event.clientX, y: event.clientY };
      };

      const onMouseMove = (event: MouseEvent) => {
        if (!isDragging) return;

        const deltaMove = {
          x: event.clientX - previousMousePosition.x,
          y: event.clientY - previousMousePosition.y
        };

        // Rotate camera around center
        const spherical = new THREE.Spherical();
        spherical.setFromVector3(camera.position);
        spherical.theta -= deltaMove.x * 0.01;
        spherical.phi += deltaMove.y * 0.01;
        spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

        camera.position.setFromSpherical(spherical);
        camera.lookAt(0, 0, 0);

        previousMousePosition = { x: event.clientX, y: event.clientY };
      };

      const onMouseUp = () => {
        isDragging = false;
      };

      const onWheel = (event: WheelEvent) => {
        const zoomSpeed = 0.1;
        const distance = camera.position.length();
        const newDistance = Math.max(5, Math.min(100, distance + event.deltaY * zoomSpeed));
        camera.position.normalize().multiplyScalar(newDistance);
      };

      renderer.domElement.addEventListener('mousedown', onMouseDown);
      renderer.domElement.addEventListener('mousemove', onMouseMove);
      renderer.domElement.addEventListener('mouseup', onMouseUp);
      renderer.domElement.addEventListener('wheel', onWheel);
    } catch (error) {
      console.error('Error setting up controls:', error);
    }
  };

  // Start the render loop
  const startRenderLoop = () => {
    const animate = () => {
      animationIdRef.current = requestAnimationFrame(animate);
      
      if (rendererRef.current && sceneRef.current && cameraRef.current) {
        try {
          rendererRef.current.render(sceneRef.current, cameraRef.current);
          setRenderCount(c => c + 1);
        } catch (error) {
          console.error('Error during rendering:', error);
          setErrorMessage(`Render error: ${error instanceof Error ? error.message : String(error)}`);
        }
      }
    };
    animate();
  };

  // Create detailed ant geometry
  const createAntGeometry = () => {
    const antGroup = new THREE.Group();
    
    try {
      // Body (main part) - make much larger for better visibility
      const bodyGeometry = new THREE.CapsuleGeometry(1.0, 2.5, 6, 8); // Much larger size
      const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.castShadow = true;
      antGroup.add(body);

      // Head
      const headGeometry = new THREE.SphereGeometry(0.8, 12, 8); // Much larger head
      const headMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.set(0, 0, 1.5); // Adjust position for larger head
      head.castShadow = true;
      antGroup.add(head);

      // Legs (simple cylinders)
      const legGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1.5); // Much thicker and longer legs
      const legMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
      
      for (let i = 0; i < 6; i++) {
        const leg = new THREE.Mesh(legGeometry, legMaterial);
        const angle = (i / 6) * Math.PI * 2;
        const side = i < 3 ? 1 : -1;
        leg.position.set(
          Math.cos(angle) * 1.2 * side, // Wider leg spread
          -0.8, // Lower leg position
          Math.sin(angle) * 0.6
        );
        leg.rotation.z = side * Math.PI * 0.3;
        leg.castShadow = true;
        antGroup.add(leg);
      }
    } catch (error) {
      console.error('Error creating ant geometry:', error);
    }

    return antGroup;
  };

  // Update ant positions
  useEffect(() => {
    if (!sceneRef.current || !antGroupRef.current || !isInitialized) return;

    try {
      const antGroup = antGroupRef.current;

      console.log(`Updating ${antData.length} ants...`);

      // Clear existing ants
      while (antGroup.children.length > 0) {
        antGroup.remove(antGroup.children[0]);
      }
      antMeshesRef.current = {};

      // Debug info with more detailed position analysis
      let debugText = `Rendering ${antData.length} ants (max 1000)\n`;
      
      if (antData.length > 0) {
        // Analyze position distribution
        const positions = antData.slice(0, 10).map(ant => ant.position);
        const avgX = positions.reduce((sum, pos) => sum + pos.x, 0) / positions.length;
        const avgZ = positions.reduce((sum, pos) => sum + pos.z, 0) / positions.length;
        const spreadX = Math.max(...positions.map(p => p.x)) - Math.min(...positions.map(p => p.x));
        const spreadZ = Math.max(...positions.map(p => p.z)) - Math.min(...positions.map(p => p.z));
        
        debugText += `Position Analysis:\n`;
        debugText += `  Avg pos: (${avgX.toFixed(2)}, ${avgZ.toFixed(2)})\n`;
        debugText += `  Spread: X=${spreadX.toFixed(2)}, Z=${spreadZ.toFixed(2)}\n`;
        debugText += `Food sources: ${environmentData?.foodSources?.length || 0}\n`;
        debugText += `Pheromone fields: ${pheromoneData?.length || 0}\n`;
        
        // Analyze ant tasks and movement
        const tasks = antData.slice(0, 20).reduce((acc, ant) => {
          acc[ant.task] = (acc[ant.task] || 0) + 1;
          return acc;
        }, {} as Record<string, number>);
        debugText += `Tasks: ${JSON.stringify(tasks)}\n`;
        
        // Check if ants are actually moving
        const speeds = antData.slice(0, 5).map(ant => ant.speed || 0);
        const avgSpeed = speeds.reduce((sum, speed) => sum + speed, 0) / speeds.length;
        debugText += `Avg speed: ${avgSpeed.toFixed(3)}\n`;
        
        debugText += `Sample positions:\n`;
        positions.slice(0, 5).forEach((pos, i) => {
          debugText += `  ${i}: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})\n`;
        });
      } else {
        debugText += 'No ant data available\n';
      }
      
      // Create new ant meshes with MUCH LARGER, more visible ants
      antData.slice(0, Math.min(antData.length, 1000)).forEach((ant, index) => { // Render up to 1000 ants
        try {
          // Create a more visible ant
          let antColor = 0x8B4513; // Default brown
          
          // Color by caste
          switch (ant.caste) {
            case 'queen':
              antColor = 0xFFD700; // Gold
              break;
            case 'worker':
              antColor = 0x8B4513; // Brown
              break;
            case 'soldier':
              antColor = 0x800000; // Dark red
              break;
            default:
              antColor = 0x8B4513;
          }

          // Highlight selected ant
          if (selectedAnt === ant.id) {
            antColor = 0xFF0000; // Red for selected
          }

          // Create detailed ant (use geometry function or simple sphere)
          const antMesh = createAntGeometry();
          
          // Apply color to all materials
          antMesh.traverse((child) => {
            if (child instanceof THREE.Mesh) {
              child.material = child.material.clone();
              
              // Color by overlay state or default
              if (overlayStates.taskColors) {
                // Color by task
                switch (ant.task) {
                  case 'forage':
                    antColor = 0x00FF00; // Green for foraging
                    break;
                  case 'construct':
                    antColor = 0x8B4513; // Brown for construction
                    break;
                  case 'defend':
                    antColor = 0xFF0000; // Red for defense
                    break;
                  case 'rest':
                    antColor = 0x808080; // Gray for resting
                    break;
                  default:
                    antColor = 0xFFFF00; // Yellow for idle/other
                }
              }
              
              child.material.color.setHex(antColor);
              child.castShadow = true;
            }
          });
          
          // Position ant - make sure it's ABOVE ground
          antMesh.position.set(
            ant.position.x,
            Math.max(ant.position.y, 2.0), // Higher above ground for larger ants
            ant.position.z
          );
          
          // Scale up the ant much more for better visibility
          antMesh.scale.set(3.0, 3.0, 3.0); // Much larger scale
          
          // Debug extreme clustering by adding small random offset if positions are too similar
          if (index > 0) {
            const prevAnt = antData[index - 1];
            const distance = Math.sqrt(
              Math.pow(ant.position.x - prevAnt.position.x, 2) + 
              Math.pow(ant.position.z - prevAnt.position.z, 2)
            );
            if (distance < 0.1) { // If ants are too close
              antMesh.position.x += (Math.random() - 0.5) * 2; // Add small random offset
              antMesh.position.z += (Math.random() - 0.5) * 2;
            }
          }
          
          // Rotate ant based on movement direction
          antMesh.rotation.y = ant.rotation || 0;
          
          // Store ant ID for click detection
          antMesh.userData = { antId: ant.id };
          
          // Add to group
          antGroup.add(antMesh);
          antMeshesRef.current[ant.id] = antMesh;

          // Debug first few ants
          if (index < 5) {
            debugText += `Ant ${index}: pos(${ant.position.x.toFixed(1)}, ${ant.position.y.toFixed(1)}, ${ant.position.z.toFixed(1)})\n`;
          }
        } catch (antError) {
          console.error(`Error creating ant ${ant.id}:`, antError);
        }
      });

      setDebugInfo(debugText);
      console.log(`Successfully created ${Object.keys(antMeshesRef.current).length} ant meshes`);

      // Update visual debug overlays
      if (visualDebugRendererRef.current) {
        visualDebugRendererRef.current.updateOverlays(antData.slice(0, 1000), overlayStates);
      }
    } catch (error) {
      console.error('Error updating ants:', error);
      setErrorMessage(`Error updating ants: ${error instanceof Error ? error.message : String(error)}`);
    }
  }, [antData, selectedAnt, isInitialized, overlayStates]); // Add overlayStates dependency

  // Update pheromone visualization (keep existing code but with smaller scale)
  useEffect(() => {
    if (!sceneRef.current || !isInitialized) return;

    const scene = sceneRef.current;

    // Remove old pheromone system
    if (pheromoneSystemRef.current) {
      scene.remove(pheromoneSystemRef.current);
    }

    if (pheromoneData.length > 0) {
      // Create pheromone visualization from grid data
      pheromoneData.forEach(pheromoneField => {
        const { concentrationGrid, width, height, cellSize } = pheromoneField;
        
        // Create points for visible pheromone concentrations
        const positions: number[] = [];
        const colors: number[] = [];
        
        for (let x = 0; x < width; x++) {
          for (let y = 0; y < height; y++) {
            const index = y * width + x;
            const concentration = concentrationGrid[index];
            
            if (concentration > 0.01) { // Only show visible concentrations
              // World position (smaller scale)
              const worldX = (x - width / 2) * cellSize * 0.5; // Scale down
              const worldZ = (y - height / 2) * cellSize * 0.5; // Scale down
              
              positions.push(worldX, 0.1, worldZ);
              
              // Color based on pheromone type
              switch (pheromoneField.type) {
                case 'trail':
                  colors.push(0, 1, 0); // Green
                  break;
                case 'alarm':
                  colors.push(1, 0, 0); // Red
                  break;
                case 'recruitment':
                  colors.push(0, 0, 1); // Blue
                  break;
                default:
                  colors.push(1, 1, 0); // Yellow
              }
            }
          }
        }
        
        if (positions.length > 0) {
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
          geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

          const material = new THREE.PointsMaterial({
            size: 4, // Larger points
            vertexColors: true,
            transparent: true,
            opacity: 0.8
          });

          const pheromoneSystem = new THREE.Points(geometry, material);
          scene.add(pheromoneSystem);
          pheromoneSystemRef.current = pheromoneSystem;
        }
      });
    }
  }, [pheromoneData, isInitialized]);

  // Handle food sources (make them more visible)
  useEffect(() => {
    if (!sceneRef.current || !isInitialized || !environmentData?.foodSources) return;

    const scene = sceneRef.current;

    console.log(`Rendering ${environmentData.foodSources.length} food sources`);

    environmentData.foodSources.forEach((food: FoodSource) => {
      const foodGeometry = new THREE.SphereGeometry(2, 12, 8); // Larger, more visible food
      const foodMaterial = new THREE.MeshLambertMaterial({ 
        color: 0x00FF00,
        emissive: 0x004400 // Make it glow slightly
      });
      const foodMesh = new THREE.Mesh(foodGeometry, foodMaterial);
      foodMesh.position.set(food.position.x, food.position.y + 1, food.position.z); // No scaling, use actual positions
      foodMesh.castShadow = true;
      scene.add(foodMesh);
      
      // Add a glowing effect around food
      const glowGeometry = new THREE.SphereGeometry(3, 8, 6);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0x00FF00,
        transparent: true,
        opacity: 0.3
      });
      const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
      glowMesh.position.copy(foodMesh.position);
      scene.add(glowMesh);
    });
  }, [environmentData, isInitialized]);

  // Handle overlay toggle
  const handleOverlayToggle = (overlay: string, enabled: boolean) => {
    setOverlayStates(prev => ({ ...prev, [overlay]: enabled }));
    
    // Update pheromone trail visibility
    if (overlay === 'pheromoneTrails' && visualDebugRendererRef.current) {
      if (enabled) {
        visualDebugRendererRef.current.renderPheromoneTrails(pheromoneData);
      }
    }
  };

  // Handle ant selection with visual debug
  const handleAntSelected = (antId: string) => {
    onAntSelected?.(antId);
    
    // Highlight selected ant
    if (visualDebugRendererRef.current) {
      // Remove previous highlight
      if (selectedAnt) {
        visualDebugRendererRef.current.removeHighlight(selectedAnt);
      }
      
      // Add new highlight
      const ant = antData.find(a => a.id === antId);
      if (ant) {
        visualDebugRendererRef.current.highlightAnt(antId, ant);
      }
    }
  };

  // Handle simulation controls
  const handleSimulationControl = (action: 'play' | 'pause' | 'step' | 'reset' | 'speed', value?: number) => {
    // These would typically communicate with the main process
    console.log(`Simulation control: ${action}`, value);
    // TODO: Implement IPC communication to control simulation
  };

  // Handle window resize
  useEffect(() => {
    const handleResize = () => {
      if (cameraRef.current && rendererRef.current) {
        cameraRef.current.aspect = window.innerWidth / window.innerHeight;
        cameraRef.current.updateProjectionMatrix();
        rendererRef.current.setSize(window.innerWidth, window.innerHeight);
      }
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return (
    <div 
      ref={mountRef} 
      style={{ 
        width: '100%', 
        height: '100vh',
        position: 'relative',
        overflow: 'hidden'
      }}
      onClick={(e) => {
        // Implement ant selection on click
        if (!rendererRef.current || !cameraRef.current || !sceneRef.current) return;
        
        const rect = rendererRef.current.domElement.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(x, y);
        raycaster.setFromCamera(mouse, cameraRef.current);
        
        const antObjects = Object.values(antMeshesRef.current);
        const intersects = raycaster.intersectObjects(antObjects, true);
        
        if (intersects.length > 0) {
          let selectedObject = intersects[0].object;
          while (selectedObject && selectedObject.parent && !selectedObject.userData?.antId) {
            selectedObject = selectedObject.parent;
          }
          
          if (selectedObject && selectedObject.userData?.antId) {
            handleAntSelected(selectedObject.userData.antId);
          }
        }
      }}
    >
      {/* Dev Tools Panel */}
      {showDevTools && (
        <DevToolsPanel
          antData={antData}
          pheromoneData={pheromoneData}
          environmentData={environmentData}
          simulationState={simulationState}
          selectedAnt={selectedAnt}
          onAntSelect={handleAntSelected}
          onToggleOverlay={handleOverlayToggle}
          onSimulationControl={handleSimulationControl}
        />
      )}

      {/* Toggle Dev Tools Button */}
      <button
        onClick={() => setShowDevTools(!showDevTools)}
        style={{
          position: 'absolute',
          top: '10px',
          left: '10px',
          background: 'rgba(0,0,0,0.8)',
          color: 'white',
          border: '1px solid #333',
          padding: '8px 12px',
          borderRadius: '4px',
          cursor: 'pointer',
          zIndex: 9999,
          fontFamily: 'monospace',
          fontSize: '12px'
        }}
      >
        üîß {showDevTools ? 'Hide' : 'Show'} Dev Tools
      </button>

      {/* Original UI Overlay - Only show when dev tools are hidden */}
      {!showDevTools && (
        <div style={{
          position: 'absolute',
          top: '10px',
          left: '10px',
          color: 'white',
          background: 'rgba(0,0,0,0.8)',
          padding: '15px',
          borderRadius: '8px',
          fontFamily: 'monospace',
          fontSize: '12px',
          zIndex: 1000,
          maxWidth: '300px'
        }}>
          <div style={{ color: '#00ff00', fontWeight: 'bold', marginBottom: '10px' }}>
            üêú Ant Farm Status
          </div>
          <div>Ants: {antData.length}</div>
          <div>Visible: {Object.keys(antMeshesRef.current).length}</div>
          <div>Pheromones: {pheromoneData.length}</div>
          <div>Simulation: {simulationState?.isRunning ? 'üü¢ Running' : 'üî¥ Paused'}</div>
          <div>Render Count: {renderCount}</div>
          {selectedAnt && <div>Selected: {selectedAnt}</div>}
          
          <div style={{ marginTop: '10px', fontSize: '10px', color: '#cccccc' }}>
            <strong>Controls:</strong><br/>
            ‚Ä¢ Mouse drag: Rotate camera<br/>
            ‚Ä¢ Mouse wheel: Zoom<br/>
            ‚Ä¢ Click on ant: Select
          </div>
          
          {debugInfo && (
            <div style={{ marginTop: '10px', fontSize: '10px', color: '#ffff00' }}>
              <strong>Debug:</strong><br/>
              <pre>{debugInfo}</pre>
            </div>
          )}
          
          {errorMessage && (
            <div style={{ marginTop: '10px', fontSize: '10px', color: '#ff6666', background: '#330000', padding: '5px' }}>
              <strong>Error:</strong><br/>
              <pre>{errorMessage}</pre>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default AdvancedThreeJSRenderer;